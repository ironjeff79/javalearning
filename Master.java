package Chapter13;
//主人类
public class Master {
	/*假设主人起初的时候只喜欢养宠物狗狗
	public void feed (Dogs d) {
		d.eat();
	}
	//由于新的需求产生，导致我们“不得不”去修改Master这个类的代码
	public void feed(Cats c) {
		c.eat();
	}
	*/
	//即使主人又喜欢养其他宠物之后，也不再想修改这个类时，就需要使用多态机制。
    //最好不要写具体的宠物类型，这样会影响程序的扩展性。
	public void feed(Animals animal) {
		//编译的时候，编译器发现animal是Animals类，回去Animals类中找eat()方法，结果找到了，编译通过。
		//运行的时候，底层实际的对象是什么，就自动调用到该实际对象对应的eat()方法上。这就是多态。
		animal.eat();
	}
}

/*分析：
   主人起初的时候只喜欢养宠物狗狗
   随着时间的推移，又喜欢上养猫咪
   实际开发中，这就表示客户产生了新的需求
   在不使用多态机制的前提下，我们只能在Master类中添加一个新的方法。 

 思考： 软件在扩展新需求的过程当中，修改Master这个类有什么问题？
要记住： 软件在扩展过程当中，修改的越少越好。
       修改的越多，你的系统当前的稳定性就越差，未知的风险就越多。
软件的开发的七大原则之一：OCP（开闭原则）
什么是开闭原则？
    对扩展开放，对修改关闭
    在软件的扩展过程中，修改的越少越好。
    
软件的扩展性？
    面向父类型编程，面向更加抽象进行编程，不建议面向具体编程。因为面向具体会让软件的扩展力很差。    

*/

